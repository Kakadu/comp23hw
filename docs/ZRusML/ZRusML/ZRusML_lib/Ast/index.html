<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ast (ZRusML.ZRusML_lib.Ast)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.3.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">ZRusML</a> &#x00BB; <a href="../index.html">ZRusML_lib</a> &#x00BB; Ast</nav><header class="odoc-preamble"><h1>Module <code><span>ZRusML_lib.Ast</span></code></h1><p>Copyright 2023-2024, Rustam Shangareev and Danil Yevdokimov</p></header><div class="odoc-content"><p>SPDX-License-Identifier: LGPL-2.1</p><p>Abstract Syntax Tree representation for the language</p><div class="odoc-spec"><div class="spec type anchored" id="type-id"><a href="#type-id" class="anchor"></a><code><span><span class="keyword">type</span> id</span><span> = string</span></code></div><div class="spec-doc"><p>Identifier type, usually representing variable names</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_id"><a href="#val-pp_id" class="anchor"></a><code><span><span class="keyword">val</span> pp_id : 
  <span><span class="xref-unresolved">Ppx_deriving_runtime</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-show_id"><a href="#val-show_id" class="anchor"></a><code><span><span class="keyword">val</span> show_id : <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-bin_op"><a href="#type-bin_op" class="anchor"></a><code><span><span class="keyword">type</span> bin_op</span><span> = </span></code><ol><li id="type-bin_op.And" class="def variant constructor anchored"><a href="#type-bin_op.And" class="anchor"></a><code><span>| </span><span><span class="constructor">And</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Logical and</p><span class="comment-delim">*)</span></div></li><li id="type-bin_op.Or" class="def variant constructor anchored"><a href="#type-bin_op.Or" class="anchor"></a><code><span>| </span><span><span class="constructor">Or</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Logical or</p><span class="comment-delim">*)</span></div></li><li id="type-bin_op.Less" class="def variant constructor anchored"><a href="#type-bin_op.Less" class="anchor"></a><code><span>| </span><span><span class="constructor">Less</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Less than</p><span class="comment-delim">*)</span></div></li><li id="type-bin_op.Leq" class="def variant constructor anchored"><a href="#type-bin_op.Leq" class="anchor"></a><code><span>| </span><span><span class="constructor">Leq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Less or equal</p><span class="comment-delim">*)</span></div></li><li id="type-bin_op.Gre" class="def variant constructor anchored"><a href="#type-bin_op.Gre" class="anchor"></a><code><span>| </span><span><span class="constructor">Gre</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Greater than</p><span class="comment-delim">*)</span></div></li><li id="type-bin_op.Geq" class="def variant constructor anchored"><a href="#type-bin_op.Geq" class="anchor"></a><code><span>| </span><span><span class="constructor">Geq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Greater or equal</p><span class="comment-delim">*)</span></div></li><li id="type-bin_op.Eq" class="def variant constructor anchored"><a href="#type-bin_op.Eq" class="anchor"></a><code><span>| </span><span><span class="constructor">Eq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Equality</p><span class="comment-delim">*)</span></div></li><li id="type-bin_op.Neq" class="def variant constructor anchored"><a href="#type-bin_op.Neq" class="anchor"></a><code><span>| </span><span><span class="constructor">Neq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Not equal</p><span class="comment-delim">*)</span></div></li><li id="type-bin_op.Add" class="def variant constructor anchored"><a href="#type-bin_op.Add" class="anchor"></a><code><span>| </span><span><span class="constructor">Add</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Addition</p><span class="comment-delim">*)</span></div></li><li id="type-bin_op.Sub" class="def variant constructor anchored"><a href="#type-bin_op.Sub" class="anchor"></a><code><span>| </span><span><span class="constructor">Sub</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Subtraction</p><span class="comment-delim">*)</span></div></li><li id="type-bin_op.Mul" class="def variant constructor anchored"><a href="#type-bin_op.Mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Mul</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Multiplication</p><span class="comment-delim">*)</span></div></li><li id="type-bin_op.Div" class="def variant constructor anchored"><a href="#type-bin_op.Div" class="anchor"></a><code><span>| </span><span><span class="constructor">Div</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Division</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Binary operations available in the language</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-un_op"><a href="#type-un_op" class="anchor"></a><code><span><span class="keyword">type</span> un_op</span><span> = </span></code><ol><li id="type-un_op.Not" class="def variant constructor anchored"><a href="#type-un_op.Not" class="anchor"></a><code><span>| </span><span><span class="constructor">Not</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Logical not</p><span class="comment-delim">*)</span></div></li><li id="type-un_op.Minus" class="def variant constructor anchored"><a href="#type-un_op.Minus" class="anchor"></a><code><span>| </span><span><span class="constructor">Minus</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unary minus</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Unary operations available in the language</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-const"><a href="#type-const" class="anchor"></a><code><span><span class="keyword">type</span> const</span><span> = </span></code><ol><li id="type-const.CInt" class="def variant constructor anchored"><a href="#type-const.CInt" class="anchor"></a><code><span>| </span><span><span class="constructor">CInt</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer constant</p><span class="comment-delim">*)</span></div></li><li id="type-const.CBool" class="def variant constructor anchored"><a href="#type-const.CBool" class="anchor"></a><code><span>| </span><span><span class="constructor">CBool</span> <span class="keyword">of</span> bool</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean constant</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Constants available in the language</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pt"><a href="#type-pt" class="anchor"></a><code><span><span class="keyword">type</span> pt</span><span> = </span></code><ol><li id="type-pt.PtWild" class="def variant constructor anchored"><a href="#type-pt.PtWild" class="anchor"></a><code><span>| </span><span><span class="constructor">PtWild</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Wildcard pattern</p><span class="comment-delim">*)</span></div></li><li id="type-pt.PtVar" class="def variant constructor anchored"><a href="#type-pt.PtVar" class="anchor"></a><code><span>| </span><span><span class="constructor">PtVar</span> <span class="keyword">of</span> <a href="#type-id">id</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variable pattern</p><span class="comment-delim">*)</span></div></li><li id="type-pt.PtConst" class="def variant constructor anchored"><a href="#type-pt.PtConst" class="anchor"></a><code><span>| </span><span><span class="constructor">PtConst</span> <span class="keyword">of</span> <a href="#type-const">const</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Constant pattern</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Patterns available in the language for pattern matching</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-binding"><a href="#type-binding" class="anchor"></a><code><span><span class="keyword">type</span> binding</span><span> = bool * <a href="#type-pt">pt</a> * <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Binding type for let expressions and function arguments</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-exp"><a href="#type-exp" class="anchor"></a><code><span><span class="keyword">and</span> exp</span><span> = </span></code><ol><li id="type-exp.EConst" class="def variant constructor anchored"><a href="#type-exp.EConst" class="anchor"></a><code><span>| </span><span><span class="constructor">EConst</span> <span class="keyword">of</span> <a href="#type-const">const</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Constants</p><span class="comment-delim">*)</span></div></li><li id="type-exp.EUnOp" class="def variant constructor anchored"><a href="#type-exp.EUnOp" class="anchor"></a><code><span>| </span><span><span class="constructor">EUnOp</span> <span class="keyword">of</span> <a href="#type-un_op">un_op</a> * <a href="#type-exp">exp</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unary operations</p><span class="comment-delim">*)</span></div></li><li id="type-exp.EVar" class="def variant constructor anchored"><a href="#type-exp.EVar" class="anchor"></a><code><span>| </span><span><span class="constructor">EVar</span> <span class="keyword">of</span> <a href="#type-id">id</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variables</p><span class="comment-delim">*)</span></div></li><li id="type-exp.ELet" class="def variant constructor anchored"><a href="#type-exp.ELet" class="anchor"></a><code><span>| </span><span><span class="constructor">ELet</span> <span class="keyword">of</span> <span><a href="#type-binding">binding</a> list</span> * <a href="#type-exp">exp</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Let expressions</p><span class="comment-delim">*)</span></div></li><li id="type-exp.EFun" class="def variant constructor anchored"><a href="#type-exp.EFun" class="anchor"></a><code><span>| </span><span><span class="constructor">EFun</span> <span class="keyword">of</span> <a href="#type-pt">pt</a> * <a href="#type-exp">exp</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function definitions</p><span class="comment-delim">*)</span></div></li><li id="type-exp.EIf" class="def variant constructor anchored"><a href="#type-exp.EIf" class="anchor"></a><code><span>| </span><span><span class="constructor">EIf</span> <span class="keyword">of</span> <a href="#type-exp">exp</a> * <a href="#type-exp">exp</a> * <a href="#type-exp">exp</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Conditional expressions</p><span class="comment-delim">*)</span></div></li><li id="type-exp.EBinOp" class="def variant constructor anchored"><a href="#type-exp.EBinOp" class="anchor"></a><code><span>| </span><span><span class="constructor">EBinOp</span> <span class="keyword">of</span> <a href="#type-bin_op">bin_op</a> * <a href="#type-exp">exp</a> * <a href="#type-exp">exp</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Binary operations</p><span class="comment-delim">*)</span></div></li><li id="type-exp.EApp" class="def variant constructor anchored"><a href="#type-exp.EApp" class="anchor"></a><code><span>| </span><span><span class="constructor">EApp</span> <span class="keyword">of</span> <a href="#type-exp">exp</a> * <a href="#type-exp">exp</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function application</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Expressions in the language</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-case"><a href="#type-case" class="anchor"></a><code><span><span class="keyword">type</span> case</span><span> = <a href="#type-pt">pt</a> * <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Case type for pattern matching</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-decl"><a href="#type-decl" class="anchor"></a><code><span><span class="keyword">type</span> decl</span><span> = </span></code><ol><li id="type-decl.DLet" class="def variant constructor anchored"><a href="#type-decl.DLet" class="anchor"></a><code><span>| </span><span><span class="constructor">DLet</span> <span class="keyword">of</span> <a href="#type-binding">binding</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>let declaration</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Declarations available in the language</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-prog"><a href="#type-prog" class="anchor"></a><code><span><span class="keyword">type</span> prog</span><span> = <span><a href="#type-decl">decl</a> list</span></span></code></div><div class="spec-doc"><p>Program type representing a list of declarations</p></div></div></div></body></html>
