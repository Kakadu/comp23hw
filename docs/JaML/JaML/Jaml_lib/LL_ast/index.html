<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>LL_ast (JaML.Jaml_lib.LL_ast)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.3.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">JaML</a> &#x00BB; <a href="../index.html">Jaml_lib</a> &#x00BB; LL_ast</nav><header class="odoc-preamble"><h1>Module <code><span>Jaml_lib.LL_ast</span></code></h1><p>Copyright 2023-2024, Ilya Pankratov, Maxim Drumov</p></header><div class="odoc-content"><p>SPDX-License-Identifier: LGPL-2.1-or-later</p><p>Almost the same ast as Typedtree. Changes: Arguments in let and let rec are represented by a list of arguments. There are no TFuns, so anonymous functions are not expressible.</p><div class="odoc-spec"><div class="spec type anchored" id="type-typed_id"><a href="#type-typed_id" class="anchor"></a><code><span><span class="keyword">type</span> typed_id</span><span> = string * <a href="../Ty/index.html#type-ty">Ty.ty</a></span></code></div><div class="spec-doc"><p>Typed function name</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-typed_arg"><a href="#type-typed_arg" class="anchor"></a><code><span><span class="keyword">type</span> typed_arg</span><span> = </span></code><ol><li id="type-typed_arg.Used" class="def variant constructor anchored"><a href="#type-typed_arg.Used" class="anchor"></a><code><span>| </span><span><span class="constructor">Used</span> <span class="keyword">of</span> string * <a href="../Ty/index.html#type-ty">Ty.ty</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Represent usual argument</p><span class="comment-delim">*)</span></div></li><li id="type-typed_arg.Unused" class="def variant constructor anchored"><a href="#type-typed_arg.Unused" class="anchor"></a><code><span>| </span><span><span class="constructor">Unused</span> <span class="keyword">of</span> <a href="../Ty/index.html#type-ty">Ty.ty</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Represent unused arguments (wildcard for example)</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Typed argument to separate the arguments used and no</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-typed_binop"><a href="#type-typed_binop" class="anchor"></a><code><span><span class="keyword">type</span> typed_binop</span><span> = <a href="../Ast/index.html#type-bin_op">Ast.bin_op</a> * <a href="../Ty/index.html#type-ty">Ty.ty</a></span></code></div><div class="spec-doc"><p>Typed sign of a binary operation</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-llexpr"><a href="#type-llexpr" class="anchor"></a><code><span><span class="keyword">type</span> llexpr</span><span> = </span></code><ol><li id="type-llexpr.LConst" class="def variant constructor anchored"><a href="#type-llexpr.LConst" class="anchor"></a><code><span>| </span><span><span class="constructor">LConst</span> <span class="keyword">of</span> <a href="../Ast/index.html#type-const">Ast.const</a> * <a href="../Ty/index.html#type-ty">Ty.ty</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Typed expression for the constant</p><span class="comment-delim">*)</span></div></li><li id="type-llexpr.LVar" class="def variant constructor anchored"><a href="#type-llexpr.LVar" class="anchor"></a><code><span>| </span><span><span class="constructor">LVar</span> <span class="keyword">of</span> string * <a href="../Ty/index.html#type-ty">Ty.ty</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Typed expression for the variables</p><span class="comment-delim">*)</span></div></li><li id="type-llexpr.LTuple" class="def variant constructor anchored"><a href="#type-llexpr.LTuple" class="anchor"></a><code><span>| </span><span><span class="constructor">LTuple</span> <span class="keyword">of</span> <span><a href="#type-llexpr">llexpr</a> list</span> * <a href="../Ty/index.html#type-ty">Ty.ty</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Typed expression for the tuples</p><span class="comment-delim">*)</span></div></li><li id="type-llexpr.LBinop" class="def variant constructor anchored"><a href="#type-llexpr.LBinop" class="anchor"></a><code><span>| </span><span><span class="constructor">LBinop</span> <span class="keyword">of</span> <a href="#type-typed_binop">typed_binop</a> * <a href="#type-llexpr">llexpr</a> * <a href="#type-llexpr">llexpr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Typed expression for the binary operations</p><span class="comment-delim">*)</span></div></li><li id="type-llexpr.LApp" class="def variant constructor anchored"><a href="#type-llexpr.LApp" class="anchor"></a><code><span>| </span><span><span class="constructor">LApp</span> <span class="keyword">of</span> <a href="#type-llexpr">llexpr</a> * <a href="#type-llexpr">llexpr</a> * <a href="../Ty/index.html#type-ty">Ty.ty</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Typed expression for the function application to the arguments</p><span class="comment-delim">*)</span></div></li><li id="type-llexpr.LIfThenElse" class="def variant constructor anchored"><a href="#type-llexpr.LIfThenElse" class="anchor"></a><code><span>| </span><span><span class="constructor">LIfThenElse</span> <span class="keyword">of</span> <a href="#type-llexpr">llexpr</a> * <a href="#type-llexpr">llexpr</a> * <a href="#type-llexpr">llexpr</a> * <a href="../Ty/index.html#type-ty">Ty.ty</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Typed expression for condition statement</p><span class="comment-delim">*)</span></div></li><li id="type-llexpr.LLetIn" class="def variant constructor anchored"><a href="#type-llexpr.LLetIn" class="anchor"></a><code><span>| </span><span><span class="constructor">LLetIn</span> <span class="keyword">of</span> <a href="#type-typed_id">typed_id</a> * <a href="#type-llexpr">llexpr</a> * <a href="#type-llexpr">llexpr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Typed expression for let in declaration</p><span class="comment-delim">*)</span></div></li><li id="type-llexpr.LTake" class="def variant constructor anchored"><a href="#type-llexpr.LTake" class="anchor"></a><code><span>| </span><span><span class="constructor">LTake</span> <span class="keyword">of</span> <a href="#type-llexpr">llexpr</a> * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A constructor for getting rid of tuples as a matchmaking pattern. By index in the list.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Typed expression type</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-llbinding"><a href="#type-llbinding" class="anchor"></a><code><span><span class="keyword">type</span> llbinding</span><span> = </span></code><ol><li id="type-llbinding.LLet" class="def variant constructor anchored"><a href="#type-llbinding.LLet" class="anchor"></a><code><span>| </span><span><span class="constructor">LLet</span> <span class="keyword">of</span> <a href="#type-typed_id">typed_id</a> * <span><a href="#type-typed_arg">typed_arg</a> list</span> * <a href="#type-llexpr">llexpr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Typed expression for let declaration</p><span class="comment-delim">*)</span></div></li><li id="type-llbinding.LLetRec" class="def variant constructor anchored"><a href="#type-llbinding.LLetRec" class="anchor"></a><code><span>| </span><span><span class="constructor">LLetRec</span> <span class="keyword">of</span> <a href="#type-typed_id">typed_id</a> * <span><a href="#type-typed_arg">typed_arg</a> list</span> * <a href="#type-llexpr">llexpr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Typed expression for let rec declaration</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Typed binding type</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-llstatements"><a href="#type-llstatements" class="anchor"></a><code><span><span class="keyword">type</span> llstatements</span><span> = <span><a href="#type-llbinding">llbinding</a> list</span></span></code></div><div class="spec-doc"><p>Typed statements type</p></div></div></div></body></html>
